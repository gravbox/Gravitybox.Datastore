//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.IO;
using System.Data.Linq;
using System.Linq.Expressions;
using System.Data.SqlClient;
using Gravitybox.Datastore.EFDAL;
using Gravitybox.Datastore.EFDAL.Entity;
using Gravitybox.Datastore.EFDAL.Exceptions;

namespace Gravitybox.Datastore.EFDAL
{
	#region LinqSQLField

	internal class LinqSQLField
	{
		public string Name { get; set; }
		public string Alias { get; set; }
		public string Table { get; set; }

		public LinqSQLField(string name, string alias, string table)
		{
			this.Name = name.Replace("[", string.Empty).Replace("]", string.Empty);
			this.Alias = alias.Replace("[", string.Empty).Replace("]", string.Empty);
			this.Table = table.Replace("[", string.Empty).Replace("]", string.Empty);
		}

		public string GetSQL(bool useAlias)
		{
			if (useAlias)
				return "[" + this.Table + "].[" + this.Name + "] AS [" + this.Alias + "]";
			else
				return "[" + this.Table + "].[" + this.Name + "]";
		}

		public override string ToString()
		{
			return GetSQL(true);
		}

	}

	#endregion

	#region LinqSQLFromClause

	internal class LinqSQLFromClause
	{
		public string TableName { get; set; }
		public string Schema { get; set; }
		public string Alias { get; set; }
		public string LinkClause { get; set; }
		public string AnchorAlias { get; set; }

		public LinqSQLFromClause(string tableName, string schema, string alias, string linkClause)
		{
			this.AnchorAlias = string.Empty;
			this.Schema = schema;
			this.TableName = tableName.Replace("[", string.Empty).Replace("]", string.Empty);
			this.Alias = alias.Replace("[", string.Empty).Replace("]", string.Empty);
			this.LinkClause = linkClause;
		}
	}

	internal class LinqSQLFromClauseCollection : List<LinqSQLFromClause>
	{
		public bool ContainsTable(string tableName)
		{
			foreach (var item in this)
			{
				if (item.TableName == tableName) return true;
			}
			return false;
		}

		public LinqSQLFromClause GetByTable(string tableName)
		{
			foreach (var item in this)
			{
				if (item.TableName == tableName) return item;
			}
			return null;
		}

		public LinqSQLFromClause GetByAlias(string alias)
		{
			alias = alias.Replace("[", string.Empty).Replace("]", string.Empty);
			foreach (var item in this)
			{
				if (item.Alias == alias) return item;
			}
			return null;
		}

		public string GetBaseAliasTable(string parentAlias, string baseTable)
		{
			LinqSQLFromClause root = GetByAlias(parentAlias);
			foreach (var item in this)
			{
				if (item.AnchorAlias == root.TableName)
				{
					if (item.TableName == baseTable) return item.Alias;
				}
			}
			return parentAlias;
		}

		internal string NewAlias()
		{
			int index = 1;
			foreach (var item in this)
			{
				if (item.Alias.StartsWith("z"))
				{
					int current = int.Parse(item.Alias.Substring(1, item.Alias.Length - 1));
					if (current >= index) index = current + 1;
				}
			}
			return "z" + index;
		}

		internal void RemapFromClause()
		{
			//Remap the FROM clause
			foreach (var fromClause in this)
			{
				//Loop through all child tables and remap the "parent" fields to the real child fields
				if ((fromClause.AnchorAlias == string.Empty) && (!string.IsNullOrEmpty(fromClause.LinkClause)))
				{
					string s = fromClause.LinkClause.Substring(3, fromClause.LinkClause.Length - 3);
					string[] arr1 = s.Split('=');

					string[] tfield1 = arr1[0].Trim().Split('.');
					string[] tfield2 = arr1[1].Trim().Split('.');

					string tableAlias1 = tfield1[0];
					string table1 = this.GetByAlias(tableAlias1).TableName;
					string field1 = tfield1[1];

					string tableAlias2 = tfield2[0];
					string table2 = this.GetByAlias(tableAlias2).TableName;
					string field2 = tfield2[1];

					string realTable = string.Empty;

					realTable = GetRealTableName(table1, field1);
					if (realTable != table1)
					{
						string parentAlias = GetByTable(table2).Alias;
						string chlidAlias = GetByTable(realTable).Alias;
						fromClause.LinkClause = fromClause.LinkClause.Replace("[" + parentAlias + "]." + field2, "[" + chlidAlias + "]." + field2);
					}

					realTable = GetRealTableName(table2, field2);
					if (realTable != table2)
					{
						string parentAlias = GetByTable(table2).Alias;
						string chlidAlias = GetByTable(realTable).Alias;
						fromClause.LinkClause = fromClause.LinkClause.Replace("[" + parentAlias + "]." + field2, "[" + chlidAlias + "]." + field2);
					}

				}
			}
		}

		internal string GetRealTableName(string parentTable, string field)
		{
			field = field.Replace("[", string.Empty).Replace("]", string.Empty);
			string realTable = string.Empty;
			if (parentTable == "AppliedPatch") realTable = Gravitybox.Datastore.EFDAL.Entity.AppliedPatch.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "CacheInvalidate") realTable = Gravitybox.Datastore.EFDAL.Entity.CacheInvalidate.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "ConfigurationSetting") realTable = Gravitybox.Datastore.EFDAL.Entity.ConfigurationSetting.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "DeleteQueue") realTable = Gravitybox.Datastore.EFDAL.Entity.DeleteQueue.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "DeleteQueueItem") realTable = Gravitybox.Datastore.EFDAL.Entity.DeleteQueueItem.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "Housekeeping") realTable = Gravitybox.Datastore.EFDAL.Entity.Housekeeping.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "LockStat") realTable = Gravitybox.Datastore.EFDAL.Entity.LockStat.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "Repository") realTable = Gravitybox.Datastore.EFDAL.Entity.Repository.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "RepositoryActionType") realTable = Gravitybox.Datastore.EFDAL.Entity.RepositoryActionType.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "RepositoryLog") realTable = Gravitybox.Datastore.EFDAL.Entity.RepositoryLog.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "RepositoryStat") realTable = Gravitybox.Datastore.EFDAL.Entity.RepositoryStat.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "Server") realTable = Gravitybox.Datastore.EFDAL.Entity.Server.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "ServerStat") realTable = Gravitybox.Datastore.EFDAL.Entity.ServerStat.GetTableFromFieldNameSqlMapping(field);
			else if (parentTable == "ServiceInstance") realTable = Gravitybox.Datastore.EFDAL.Entity.ServiceInstance.GetTableFromFieldNameSqlMapping(field);
			LinqSQLFromClause sqlFromClause = this.GetByTable(realTable);
			return sqlFromClause.TableName;
		}

	}

	#endregion

	#region BusinessObjectQuery

	delegate string GetDatabaseFieldNameDelegate(string field);
	internal partial class BusinessObjectQuery<T, K, P>
		where T : class, IBusinessObject
		where K : class, IBusinessObjectLINQQuery
	{
		private const int DEFAULTTIMEOUT = 30;
		public static int UpdateData(
			Expression<Func<K, P>> select,
			Expression<Func<K, bool>> where,
			IBusinessObject newValue,
			string leafTable,
			GetDatabaseFieldNameDelegate getField,
			bool hasModifyAudit,
			string connectionString = ""
			)
		{
			if (string.IsNullOrEmpty(connectionString))
				connectionString = Gravitybox.Datastore.EFDAL.DatastoreEntities.GetConnectionString();
			using (var connection = Gravitybox.Datastore.EFDAL.DBHelper.GetConnection(Gravitybox.Datastore.EFDAL.Util.StripEFCS2Normal(connectionString)))
			{
				connection.Open();
				return UpdateData(
					select,
					where,
					newValue,
					leafTable,
					getField,
					hasModifyAudit,
					null, connection, null);
			}
		}

		public static int UpdateData(
			Expression<Func<K, P>> select,
			Expression<Func<K, bool>> where,
			IBusinessObject newValue,
			string leafTable,
			GetDatabaseFieldNameDelegate getField,
			bool hasModifyAudit,
			ContextStartup startup,
			IDbConnection connection,
			System.Data.Common.DbTransaction transaction
			)
		{
			if (startup == null) startup = new ContextStartup(null);
			using (var dc = new DataContext(connection))
			{
				var template = dc.GetTable<K>();
				using (var cmd = BusinessEntityQuery.GetCommand<K, P>(dc, template, select, where))
				{
					if (!startup.DefaultTimeout && startup.CommandTimeout > 0) cmd.CommandTimeout = startup.CommandTimeout;
						else cmd.CommandTimeout = DEFAULTTIMEOUT;
					if (transaction != null)
						cmd.Transaction = transaction;
					var parser = LinqSQLParser.Create(cmd.CommandText, LinqSQLParser.ObjectTypeConstants.Table);

					var index = 0;
					var sql = "declare @totalcount int ; set @totalcount = 0;";
					foreach (var field in parser.FieldList)
					{
						sql += "UPDATE [" + parser.GetTableFromField(field.Name, leafTable) + "]\r\n";
						var value = newValue.GetType().GetProperty(field.Name).GetValue(newValue, null);
						sql += "SET [" + parser.GetTableFromField(field.Name, leafTable) + "].[" + field.Name + "] = @newValue" + index + "\r\n";

						if (hasModifyAudit && (field.Name != "ModifiedBy")) sql += ", [" + parser.GetTableFromField(field.Name, leafTable) + "].[ModifiedBy] = NULL\r\n";
						if (hasModifyAudit && (field.Name != "ModifiedDate")) sql += ", [" + parser.GetTableFromField(field.Name, leafTable) + "].[ModifiedDate] = sysdatetime()\r\n";
						sql += parser.GetFromClause(new QueryOptimizer()) + "\r\n";
						sql += parser.GetWhereClause() + ";";
						if (value == null) cmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("newValue" + index, System.DBNull.Value));
						else cmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("newValue" + index, value));

						sql += ";SET @totalcount = @totalcount + @@rowcount;";

						index++;
					}

					sql += "select @totalcount";
					cmd.CommandText = sql;
					
					object p = cmd.ExecuteScalar();
					return (int)p;
				}
			}
		}
		#region UpdateData
		public static int UpdateData(
			Expression<Func<K, P>> select,
			Expression<Func<K, bool>> where,
			P newValue,
			string leafTable,
			GetDatabaseFieldNameDelegate getField,
			bool hasModifyAudit
			)
		{
			return UpdateData(
				select,
				where,
				newValue,
				leafTable,
				getField,
				hasModifyAudit,
				Gravitybox.Datastore.EFDAL.DatastoreEntities.GetConnectionString());
		}

		public static int UpdateData(
			Expression<Func<K, P>> select,
			Expression<Func<K, bool>> where,
			P newValue,
			string leafTable,
			GetDatabaseFieldNameDelegate getField,
			bool hasModifyAudit,
			string connectionString
			)
		{
			using (var connection = Gravitybox.Datastore.EFDAL.DBHelper.GetConnection(Gravitybox.Datastore.EFDAL.Util.StripEFCS2Normal(connectionString)))
			{
				connection.Open();
				return UpdateData(
					select,
					where,
					newValue,
					leafTable,
					getField,
					hasModifyAudit,
					null,
					connection,
					null);
			}
		}

		public static int UpdateData(
			Expression<Func<K, P>> select,
			Expression<Func<K, bool>> where,
			P newValue,
			string leafTable,
			GetDatabaseFieldNameDelegate getField,
			bool hasModifyAudit,
			ContextStartup startup,
			string connectionString
			)
		{
			using (var connection = Gravitybox.Datastore.EFDAL.DBHelper.GetConnection(Gravitybox.Datastore.EFDAL.Util.StripEFCS2Normal(connectionString)))
			{
				connection.Open();
				return UpdateData(
					select,
					where,
					newValue,
					leafTable,
					getField,
					hasModifyAudit,
					startup,
					connection,
					null);
			}
		}

		public static int UpdateData(
			Expression<Func<K, P>> select,
			Expression<Func<K, bool>> where,
			P newValue,
			string leafTable,
			GetDatabaseFieldNameDelegate getField,
			bool hasModifyAudit,
			ContextStartup startup,
			IDbConnection connection,
			System.Data.Common.DbTransaction transaction
			)
		{
			if (startup == null) startup = new ContextStartup(null);
			using (var dc = new DataContext(connection))
			{
				var template = dc.GetTable<K>();
				using (var cmd = BusinessEntityQuery.GetCommand<K, P>(dc, template, select, where))
				{
					if (!startup.DefaultTimeout && startup.CommandTimeout > 0) cmd.CommandTimeout = startup.CommandTimeout;
					else cmd.CommandTimeout = DEFAULTTIMEOUT;
					if (transaction != null)
						cmd.Transaction = transaction;
					var parser = LinqSQLParser.Create(cmd.CommandText, LinqSQLParser.ObjectTypeConstants.Table);
					var fieldName = parser.GetSelectClause();
					var sql = "UPDATE [" + parser.GetTableFromField(fieldName, leafTable) + "]\r\n";
					sql += "SET [" + parser.GetTableFromField(fieldName, leafTable) + "].[" + fieldName + "] = @newValue\r\n";
					if (hasModifyAudit && (fieldName != "ModifiedBy")) sql += ", [" + parser.GetTableFromField(fieldName, leafTable) + "].[ModifiedBy] = NULL\r\n";
					if (hasModifyAudit && (fieldName != "ModifiedDate")) sql += ", [" + parser.GetTableFromField(fieldName, leafTable) + "].[ModifiedDate] = sysdatetime()\r\n";
					sql += parser.GetFromClause(new QueryOptimizer()) + "\r\n";
					sql += parser.GetWhereClause();
					sql += ";select @@rowcount";
					cmd.CommandText = sql;
					if (newValue == null) cmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("newValue", System.DBNull.Value));
					else cmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("newValue", newValue));
					object p = cmd.ExecuteScalar();
					return (int)p;
				}
			}
		}
		#endregion

	}

	#endregion

	#region LinqSQLParser

	internal partial class LinqSQLParser
	{
		internal enum ObjectTypeConstants
		{
			Table,
			View,
			StoredProcedure,
		}

		#region Static Creator

		public static LinqSQLParser Create(string sql, ObjectTypeConstants type)
		{
			return new LinqSQLParser(sql, type);
		}

		#endregion

		#region Class Members

		private string _whereClause = string.Empty;
		private string _sql = string.Empty;
		private LinqSQLFromClauseCollection _fromLinkList = new LinqSQLFromClauseCollection();
		public List<LinqSQLField> FieldList { get; private set;}
		private ObjectTypeConstants _type;

		#endregion

		#region Constructor

		private LinqSQLParser(string sql, ObjectTypeConstants type)
		{
			if ((sql == null) || (sql == string.Empty))
				throw new Exception("SQL cannot be empty.");

			this.FieldList = new List<LinqSQLField>();
			sql = sql.Replace("] AS [value]\r", "]\r");
			_type = type;
			_sql = sql;

			//Parse the string into SELECT, FROM, WHERE
			var index = sql.IndexOf("\r\nFROM") + 2;
			var selectClause = sql.Substring(0, index).Replace("\r\n", " ");
			index = sql.IndexOf("\r\nWHERE");
			if (index == -1) index = sql.Length;
			var fromClause = sql.Substring(selectClause.Length - 1, index - selectClause.Length + 1).Replace("\r\n", " ").Trim();
			fromClause = fromClause.Substring(5, fromClause.Length - 5).Trim();
			selectClause = selectClause.Trim();
			fromClause = fromClause.Trim();

			index = sql.IndexOf("\r\nWHERE");
			if (index != -1)
			{
				_whereClause = sql.Substring(index + 2, sql.Length - index - 2).Replace("\r\n", " ");
				_whereClause = _whereClause.Substring(6, _whereClause.Length - 6);
			}

			ParseFrom(fromClause);
			ParseSelect(selectClause);
			RemapParentChild();

		}

		#endregion

		#region RemapParentChild

		private void RemapParentChild()
		{
			//Include all base tables
			LinqSQLFromClauseCollection childTables = new LinqSQLFromClauseCollection();
			foreach (var fromClause in _fromLinkList)
			{
				//Do all field replacements
				if (_type == ObjectTypeConstants.Table)
				{
					if (fromClause.TableName == "AppliedPatch")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "CacheInvalidate")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "ConfigurationSetting")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "DeleteQueue")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "DeleteQueueItem")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "Housekeeping")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "LockStat")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "Repository")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "RepositoryActionType")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "RepositoryLog")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "RepositoryStat")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "Server")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "ServerStat")
					{
						childTables.Add(fromClause);
					}
					if (fromClause.TableName == "ServiceInstance")
					{
						childTables.Add(fromClause);
					}
				}
				if (_type == ObjectTypeConstants.View)
				{
				}
			}
			_fromLinkList.Clear();
			_fromLinkList.AddRange(childTables);

			//Process the FROM clause
			_fromLinkList.RemapFromClause();

			//Now map the columns to the proper tables
			foreach (var field in this.FieldList)
			{
				LinqSQLFromClause clause = _fromLinkList.FirstOrDefault(x => x.Alias == field.Table);
				string realTable = string.Empty;
				if (_type == ObjectTypeConstants.Table)
				{
					if (clause.TableName == "AppliedPatch") realTable = Gravitybox.Datastore.EFDAL.Entity.AppliedPatch.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "CacheInvalidate") realTable = Gravitybox.Datastore.EFDAL.Entity.CacheInvalidate.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "ConfigurationSetting") realTable = Gravitybox.Datastore.EFDAL.Entity.ConfigurationSetting.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "DeleteQueue") realTable = Gravitybox.Datastore.EFDAL.Entity.DeleteQueue.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "DeleteQueueItem") realTable = Gravitybox.Datastore.EFDAL.Entity.DeleteQueueItem.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "Housekeeping") realTable = Gravitybox.Datastore.EFDAL.Entity.Housekeeping.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "LockStat") realTable = Gravitybox.Datastore.EFDAL.Entity.LockStat.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "Repository") realTable = Gravitybox.Datastore.EFDAL.Entity.Repository.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "RepositoryActionType") realTable = Gravitybox.Datastore.EFDAL.Entity.RepositoryActionType.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "RepositoryLog") realTable = Gravitybox.Datastore.EFDAL.Entity.RepositoryLog.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "RepositoryStat") realTable = Gravitybox.Datastore.EFDAL.Entity.RepositoryStat.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "Server") realTable = Gravitybox.Datastore.EFDAL.Entity.Server.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "ServerStat") realTable = Gravitybox.Datastore.EFDAL.Entity.ServerStat.GetTableFromFieldAliasSqlMapping(field.Alias);
					else if (clause.TableName == "ServiceInstance") realTable = Gravitybox.Datastore.EFDAL.Entity.ServiceInstance.GetTableFromFieldAliasSqlMapping(field.Alias);
				}
				var sqlFromClause = _fromLinkList.GetByTable(realTable);
				field.Table = sqlFromClause.Alias;
			}

			//Calculate the WHERE clause
			if (!string.IsNullOrEmpty(_whereClause))
			{
				foreach (var fromClause in _fromLinkList)
				{
					//Only process table that were original and not inserted above
					if (fromClause.AnchorAlias == string.Empty)
						_whereClause = GetRemappedLinqSql(fromClause, _whereClause, _fromLinkList, _type);
				}

			}

		}

		public static string GetRemappedLinqSql(LinqSQLFromClause tableInfo, string whereClause, LinqSQLFromClauseCollection fromLinkList, ObjectTypeConstants type)
		{
			if (type == ObjectTypeConstants.Table)
			{
				switch (tableInfo.TableName)
				{
					case "AppliedPatch": return Gravitybox.Datastore.EFDAL.Entity.AppliedPatch.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "CacheInvalidate": return Gravitybox.Datastore.EFDAL.Entity.CacheInvalidate.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "ConfigurationSetting": return Gravitybox.Datastore.EFDAL.Entity.ConfigurationSetting.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "DeleteQueue": return Gravitybox.Datastore.EFDAL.Entity.DeleteQueue.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "DeleteQueueItem": return Gravitybox.Datastore.EFDAL.Entity.DeleteQueueItem.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "Housekeeping": return Gravitybox.Datastore.EFDAL.Entity.Housekeeping.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "LockStat": return Gravitybox.Datastore.EFDAL.Entity.LockStat.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "Repository": return Gravitybox.Datastore.EFDAL.Entity.Repository.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "RepositoryActionType": return Gravitybox.Datastore.EFDAL.Entity.RepositoryActionType.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "RepositoryLog": return Gravitybox.Datastore.EFDAL.Entity.RepositoryLog.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "RepositoryStat": return Gravitybox.Datastore.EFDAL.Entity.RepositoryStat.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "Server": return Gravitybox.Datastore.EFDAL.Entity.Server.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "ServerStat": return Gravitybox.Datastore.EFDAL.Entity.ServerStat.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
					case "ServiceInstance": return Gravitybox.Datastore.EFDAL.Entity.ServiceInstance.GetRemappedLinqSql(whereClause, tableInfo.Alias, fromLinkList);
				}
			}
			if (type == ObjectTypeConstants.View)
			{
			}
			if (type == ObjectTypeConstants.StoredProcedure)
			{
			}
			throw new Exception("Table not found '" + tableInfo.TableName + "'.");
		}

		#endregion

		#region ParseFrom

		private void ParseFrom(string fromClause)
		{
			const string LINKSQL = "LEFT OUTER JOIN ";
			var fromArray = fromClause.Split(new string[] { LINKSQL }, StringSplitOptions.RemoveEmptyEntries);
			var index = fromArray[0].IndexOf("]");
			var tableName = fromArray[0].Substring(1, index - 1);

			_fromLinkList.Add(new LinqSQLFromClause(tableName, GetSchema(tableName), "t0", string.Empty));

			for (int ii = 1; ii < fromArray.Length; ii++)
			{
				var rawText = fromArray[ii];

				//Get Table
				index = rawText.IndexOf("]");
				var table = rawText.Substring(0, index + 1);
				rawText = rawText.Substring(table.Length + 4, rawText.Length - table.Length - 4);

				//Get Alias
				index = rawText.IndexOf("]");
				var alias = rawText.Substring(0, index + 1);

				//Get Link
				var linkClause = rawText.Substring(alias.Length + 1, rawText.Length - alias.Length - 1);

				_fromLinkList.Add(new LinqSQLFromClause(table, GetSchema(table), alias, linkClause));
			}
		}

		#endregion

		#region ParseSelect

		private void ParseSelect(string selectClause)
		{
			//Parse fields
			var selectList = selectClause.Substring(7, selectClause.Length - 7).Split(',');
			foreach (string rawField in selectList)
			{
				var s = rawField.Trim();

				//Get Table
				var index = s.IndexOf("]");
				var table = s.Substring(0, index + 1);
				s = s.Substring(table.Length + 1, s.Length - table.Length - 1);

				//Get Name
				index = s.IndexOf("]");
				var field = s.Substring(0, index + 1);

				//Get Alias
				var alias = field;
				bool hasAlias = false;
				if (s.Length > field.Length)
				{
					alias = s.Substring(field.Length + 4, s.Length - field.Length - 4);
					hasAlias = true;
				}

				if (!hasAlias)
				{
					LinqSQLFromClause clause = _fromLinkList.FirstOrDefault(x => x.Alias == table.Replace("[", string.Empty).Replace("]", string.Empty));
					switch (clause.TableName)
					{
						case "AppliedPatch": alias = Gravitybox.Datastore.EFDAL.Entity.AppliedPatch.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "CacheInvalidate": alias = Gravitybox.Datastore.EFDAL.Entity.CacheInvalidate.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "ConfigurationSetting": alias = Gravitybox.Datastore.EFDAL.Entity.ConfigurationSetting.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "DeleteQueue": alias = Gravitybox.Datastore.EFDAL.Entity.DeleteQueue.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "DeleteQueueItem": alias = Gravitybox.Datastore.EFDAL.Entity.DeleteQueueItem.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "Housekeeping": alias = Gravitybox.Datastore.EFDAL.Entity.Housekeeping.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "LockStat": alias = Gravitybox.Datastore.EFDAL.Entity.LockStat.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "Repository": alias = Gravitybox.Datastore.EFDAL.Entity.Repository.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "RepositoryActionType": alias = Gravitybox.Datastore.EFDAL.Entity.RepositoryActionType.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "RepositoryLog": alias = Gravitybox.Datastore.EFDAL.Entity.RepositoryLog.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "RepositoryStat": alias = Gravitybox.Datastore.EFDAL.Entity.RepositoryStat.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "Server": alias = Gravitybox.Datastore.EFDAL.Entity.Server.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "ServerStat": alias = Gravitybox.Datastore.EFDAL.Entity.ServerStat.GetFieldAliasFromFieldNameSqlMapping(field); break;
						case "ServiceInstance": alias = Gravitybox.Datastore.EFDAL.Entity.ServiceInstance.GetFieldAliasFromFieldNameSqlMapping(field); break;
					}
				}

				this.FieldList.Add(new LinqSQLField(field, alias, table));
			}

		}

		#endregion

		#region Methods

		public string GetSchema(string tableName)
		{
			//There is only one schema for this API, so just hard-wire it
			return "dbo";
		}

		public string GetSelectClause()
		{
			var sb = new StringBuilder();
			foreach (var field in this.FieldList)
			{
				sb.Append(field.Name);
				if (this.FieldList.IndexOf(field) < this.FieldList.Count - 1)
					sb.Append(", ");
			}
			return sb.ToString();
		}

		public string GetFromClause(QueryOptimizer optimizer)
		{
			var sb = new StringBuilder();

			//Calculate the FROM clause
			int index = 0;
			sb.Append("FROM ");
			foreach (var fromClause in _fromLinkList)
			{
				sb.Append("[" + fromClause.Schema + "].[" + fromClause.TableName + "] AS [" + fromClause.Alias + "] ");
				if (optimizer.NoLocking) sb.Append("WITH (READUNCOMMITTED) ");
				if (!string.IsNullOrEmpty(fromClause.LinkClause)) sb.Append(fromClause.LinkClause + " ");

				if (index < _fromLinkList.Count - 1)
				{
					sb.AppendLine();
					sb.Append("LEFT OUTER JOIN ");
				}

				index++;
			}
			sb.AppendLine();
			return sb.ToString();
		}

		public string GetWhereClause()
		{
			if (!string.IsNullOrEmpty(_whereClause)) return "WHERE " + _whereClause;
			else return string.Empty;
		}

		public string GetTableFromField(string fieldName, string tableName)
		{
			return GetTableAlias((from x in this.FieldList where x.Name == fieldName select x).FirstOrDefault().Table);
		}

		public static string GetTableAlias(string tableName)
		{
			tableName = tableName.Replace("[", string.Empty).Replace("]", string.Empty);
			switch (tableName)
			{
			}
 		return tableName;
		}

		#endregion

		#region GetTextFromResource

		public static string GetTextFromResource(string resourceFileName)
		{
			try
			{
				var sb = new StringBuilder();
				var asm = Assembly.GetExecutingAssembly();
				var manifestStream = asm.GetManifestResourceStream(resourceFileName);
				try
				{
					var theReader = new BinaryReader(manifestStream);
					var theFileRead = new byte[manifestStream.Length];
					manifestStream.Read(theFileRead, 0, theFileRead.Length);
					var data = Encoding.ASCII.GetString(theFileRead);
					theReader.Close();
					return data;
				}
				catch { }
				finally
				{
					manifestStream.Close();
				}
				return string.Empty;
			}
			catch
			{
				throw;
			}
		}

		#endregion

	}

	#endregion

	#region GlobalValues

	internal static class GlobalValues
	{
		public const string ERROR_PROPERTY_NULL = "The value is null and in an invalid state.";
		public const string ERROR_PROPERTY_SETNULL = "Cannot set value to null.";
		public const string ERROR_CONCURRENCY_FAILURE = "Concurrency failure";
		public const string ERROR_CONSTRAINT_FAILURE = "Constraint failure";
		public const string ERROR_DATA_TOO_BIG = "The data '{0}' is too large for the {1} field which has a length of {2}.";
		public const string ERROR_INVALID_ENUM = "The value '{0}' set to the '{1}' field is not valid based on the backing enumeration.";
		public static readonly DateTime MIN_DATETIME = new DateTime(1753, 1, 1);
		public const string YMDHMS_FORMAT = "yyyy-MM-dd HH:mm:ss";
		public static readonly DateTime MAX_DATETIME = new DateTime(9999, 12, 31, 23, 59, 59);
		private const string INVALID_BUSINIESSOBJECT = "An invalid object of type 'IBusinessObject' was passed in. Perhaps a relationship was not enforced correctly.";

		internal static string SetValueHelperInternal(string newValue, bool fixLength, int maxDataLength)
		{
			string retval = null;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				var v = newValue.ToString();
				if (fixLength)
				{
					int fieldLength = maxDataLength;
					if ((fieldLength > 0) && (v.Length > fieldLength)) v = v.Substring(0, fieldLength);
				}
				retval = v;
			}
			return retval;
		}

		internal static double? SetValueHelperDoubleNullableInternal(object newValue)
		{
			double? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = double.Parse((string)newValue);
				}
				else if (!(newValue is double?))
				{
					retval = double.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (double?)newValue;
			}
			return retval;
		}

		internal static double SetValueHelperDoubleNotNullableInternal(object newValue, string nullMessage)
		{
			double retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = double.Parse((string)newValue);
				}
				else if (!(newValue is double))
				{
					retval = double.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (double)newValue;
			}
			return retval;
		}

		internal static DateTime? SetValueHelperDateTimeNullableInternal(object newValue)
		{
			DateTime? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = DateTime.Parse((string)newValue);
				}
				else if (!(newValue is DateTime?))
				{
					retval = DateTime.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (DateTime?)newValue;
			}
			return retval;
		}

		internal static DateTime SetValueHelperDateTimeNotNullableInternal(object newValue, string nullMessage)
		{
			DateTime retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = DateTime.Parse((string)newValue);
				}
				else if (!(newValue is DateTime))
				{
					retval = DateTime.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (DateTime)newValue;
			}
			return retval;
		}

		internal static bool? SetValueHelperBoolNullableInternal(object newValue)
		{
			bool? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = bool.Parse((string)newValue);
				}
				else if (!(newValue is bool?))
				{
					retval = bool.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (bool?)newValue;
			}
			return retval;
		}

		internal static bool SetValueHelperBoolNotNullableInternal(object newValue, string nullMessage)
		{
			bool retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = bool.Parse((string)newValue);
				}
				else if (!(newValue is bool))
				{
					retval = bool.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (bool)newValue;
			}
			return retval;
		}

		internal static int? SetValueHelperIntNullableInternal(object newValue)
		{
			int? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = int.Parse((string)newValue);
				}
				else if (!(newValue is int?))
				{
					retval = int.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (int?)newValue;
			}
			return retval;
		}

		internal static int SetValueHelperIntNotNullableInternal(object newValue, string nullMessage)
		{
			int retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = int.Parse((string)newValue);
				}
				else if (!(newValue is int))
				{
					retval = int.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (int)newValue;
			}
			return retval;
		}

		internal static long? SetValueHelperLongNullableInternal(object newValue)
		{
			long? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = long.Parse((string)newValue);
				}
				else if (!(newValue is long?))
				{
					retval = long.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (long?)newValue;
			}
			return retval;
		}

		internal static long SetValueHelperLongNotNullableInternal(object newValue, string nullMessage)
		{
			long retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = long.Parse((string)newValue);
				}
				else if (!(newValue is long))
				{
					retval = long.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (long)newValue;
			}
			return retval;
		}

		internal static T PropertyGetterLambdaErrorHandler<T>(Func<T> func)
		{
			try
			{
				return func();
			}
			catch (System.Data.DBConcurrencyException dbcex) { throw new ConcurrencyException(GlobalValues.ERROR_CONCURRENCY_FAILURE, dbcex); }
			catch (System.Data.SqlClient.SqlException sqlexp) { if (sqlexp.Number == 547 || sqlexp.Number == 2627) throw new UniqueConstraintViolatedException(GlobalValues.ERROR_CONSTRAINT_FAILURE, sqlexp); else throw; }
			catch (Exception ex) { System.Diagnostics.Debug.WriteLine(ex.ToString()); throw; }
		}

		internal static void PropertySetterLambdaErrorHandler(System.Action action)
		{
			try
			{
				action();
			}
			catch (System.Data.DBConcurrencyException dbcex) { throw new ConcurrencyException(GlobalValues.ERROR_CONCURRENCY_FAILURE, dbcex); }
			catch (System.Data.SqlClient.SqlException sqlexp) { if (sqlexp.Number == 547 || sqlexp.Number == 2627) throw new UniqueConstraintViolatedException(GlobalValues.ERROR_CONSTRAINT_FAILURE, sqlexp); else throw; }
			catch (Exception ex) { System.Diagnostics.Debug.WriteLine(ex.ToString()); throw; }
		}

	}

	#endregion

	#region Extensions

	internal static class Extensions
	{
		public static bool Contains(this DataRelationCollection relationList, DataRelation relation)
		{
			foreach (DataRelation r in relationList)
			{
				int matches = 0;
				foreach (DataColumn c in r.ChildColumns)
				{
					if (relation.ChildColumns.Contains(c))
						matches++;
				}

				foreach (DataColumn c in r.ParentColumns)
				{
					if (relation.ParentColumns.Contains(c))
						matches++;
				}

				if (r.ChildColumns.Length == (matches * 2))
					return true;

			}
			return false;
		}
	}

	#endregion
}
